'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// https://developer.twitter.com/en/docs/basics/authentication/overview/oauth

var t = require('assert');
var fs = require('fs');
var path = require('path');
var qs = require('querystring');
var crypto = require('crypto');

var compose = require('request-compose');
var Request = compose.Request;
var Response = compose.Response;
var mw = require('../');

var oauth = require('oauth-sign');
var rsaPrivatePEM = fs.readFileSync(path.join(__dirname, 'ssl', 'test.key'));

var sign = {
  reqsign: {
    request: {
      method: 'POST',
      url: 'https://api.twitter.com/oauth/request_token',
      oauth: {
        callback: 'http://localhost:3005/the_dance/process_callback?service_provider_id=11',
        consumer_key: 'GDdmIQH6jhtmLUypg82g',
        nonce: 'QP70eNmVz8jvdPevU3oJD2AfF7R7odC2XJcn4XlZJqk',
        timestamp: '1272323042',
        version: '1.0',
        consumer_secret: 'MCD8BKwGdgPHvAuvgvz4EQpqDAtx89grbuNMRd7Eh98'
      }
    },
    oauth: {
      consumer_secret: 'MCD8BKwGdgPHvAuvgvz4EQpqDAtx89grbuNMRd7Eh98',
      signature: '8wUi7m5HFQy76nowoCThusfgB+Q=',
      params: {
        oauth_callback: 'http://localhost:3005/the_dance/process_callback?service_provider_id=11',
        oauth_consumer_key: 'GDdmIQH6jhtmLUypg82g',
        oauth_nonce: 'QP70eNmVz8jvdPevU3oJD2AfF7R7odC2XJcn4XlZJqk',
        oauth_signature_method: 'HMAC-SHA1',
        oauth_timestamp: '1272323042',
        oauth_version: '1.0'
      }
    }
  },
  reqsignRSA: {
    request: {
      method: 'POST',
      url: 'https://api.twitter.com/oauth/request_token',
      oauth: {
        callback: 'http://localhost:3005/the_dance/process_callback?service_provider_id=11',
        consumer_key: 'GDdmIQH6jhtmLUypg82g',
        nonce: 'QP70eNmVz8jvdPevU3oJD2AfF7R7odC2XJcn4XlZJqk',
        timestamp: '1272323042',
        version: '1.0',
        private_key: rsaPrivatePEM,
        signature_method: 'RSA-SHA1'
      }
    },
    oauth: {
      signature: 'MXdzEnIrQco3ACPoVWxCwv5pxYrm5MFRXbsP3LfRV+zfcRr+WMp/dOPS/3r+Wcb+17Z2IK3uJ8dMHfzb5LiDNCTUIj7SWBrbxOpy3Y6SA6z3vcrtjSekkTHLek1j+mzxOi3r3fkbYaNwjHx3PyoFSazbEstnkQQotbITeFt5FBE=',
      params: {
        oauth_callback: 'http://localhost:3005/the_dance/process_callback?service_provider_id=11',
        oauth_consumer_key: 'GDdmIQH6jhtmLUypg82g',
        oauth_nonce: 'QP70eNmVz8jvdPevU3oJD2AfF7R7odC2XJcn4XlZJqk',
        oauth_signature_method: 'RSA-SHA1',
        oauth_timestamp: '1272323042',
        oauth_version: '1.0'
      }
    }
  },
  accsign: {
    request: {
      method: 'POST',
      url: 'https://api.twitter.com/oauth/access_token',
      oauth: {
        consumer_key: 'GDdmIQH6jhtmLUypg82g',
        nonce: '9zWH6qe0qG7Lc1telCn7FhUbLyVdjEaL3MO5uHxn8',
        signature_method: 'HMAC-SHA1',
        token: '8ldIZyxQeVrFZXFOZH5tAwj6vzJYuLQpl0WUEYtWc',
        timestamp: '1272323047',
        verifier: 'pDNg57prOHapMbhv25RNf75lVRd6JDsni1AJJIDYoTY',
        version: '1.0',
        consumer_secret: 'MCD8BKwGdgPHvAuvgvz4EQpqDAtx89grbuNMRd7Eh98',
        token_secret: 'x6qpRnlEmW9JbQn4PQVVeVG8ZLPEx6A0TOebgwcuA'
      }
    },
    oauth: {
      consumer_secret: 'MCD8BKwGdgPHvAuvgvz4EQpqDAtx89grbuNMRd7Eh98',
      token_secret: 'x6qpRnlEmW9JbQn4PQVVeVG8ZLPEx6A0TOebgwcuA',
      signature: 'PUw/dHA4fnlJYM6RhXk5IU/0fCc=',
      params: {
        oauth_consumer_key: 'GDdmIQH6jhtmLUypg82g',
        oauth_nonce: '9zWH6qe0qG7Lc1telCn7FhUbLyVdjEaL3MO5uHxn8',
        oauth_signature_method: 'HMAC-SHA1',
        oauth_token: '8ldIZyxQeVrFZXFOZH5tAwj6vzJYuLQpl0WUEYtWc',
        oauth_timestamp: '1272323047',
        oauth_verifier: 'pDNg57prOHapMbhv25RNf75lVRd6JDsni1AJJIDYoTY',
        oauth_version: '1.0'
      }
    }
  },
  accsignRSA: {
    request: {
      method: 'POST',
      url: 'https://api.twitter.com/oauth/access_token',
      oauth: {
        consumer_key: 'GDdmIQH6jhtmLUypg82g',
        nonce: '9zWH6qe0qG7Lc1telCn7FhUbLyVdjEaL3MO5uHxn8',
        signature_method: 'RSA-SHA1',
        token: '8ldIZyxQeVrFZXFOZH5tAwj6vzJYuLQpl0WUEYtWc',
        timestamp: '1272323047',
        verifier: 'pDNg57prOHapMbhv25RNf75lVRd6JDsni1AJJIDYoTY',
        version: '1.0',
        private_key: rsaPrivatePEM
      }
    },
    oauth: {
      signature: 'gZrMPexdgGMVUl9H6RxK0MbR6Db8tzf2kIIj52kOrDFcMgh4BunMBgUZAO1msUwz6oqZIvkVqyfyDAOP2wIrpYem0mBg3vqwPIroSE1AlUWo+TtQxOTuqrU+3kDcXpdvJe7CAX5hUx9Np/iGRqaCcgByqb9DaCcQ9ViQ+0wJiXI=',
      params: {
        oauth_consumer_key: 'GDdmIQH6jhtmLUypg82g',
        oauth_nonce: '9zWH6qe0qG7Lc1telCn7FhUbLyVdjEaL3MO5uHxn8',
        oauth_signature_method: 'RSA-SHA1',
        oauth_token: '8ldIZyxQeVrFZXFOZH5tAwj6vzJYuLQpl0WUEYtWc',
        oauth_timestamp: '1272323047',
        oauth_verifier: 'pDNg57prOHapMbhv25RNf75lVRd6JDsni1AJJIDYoTY',
        oauth_version: '1.0'
      }
    }
  },
  upsign: {
    request: {
      method: 'POST',
      url: 'http://api.twitter.com/1/statuses/update.json',
      oauth: {
        consumer_key: 'GDdmIQH6jhtmLUypg82g',
        nonce: 'oElnnMTQIZvqvlfXM56aBLAf5noGD0AQR3Fmi7Q6Y',
        signature_method: 'HMAC-SHA1',
        token: '819797-Jxq8aYUDRmykzVKrgoLhXSq67TEa5ruc4GJC2rWimw',
        timestamp: '1272325550',
        version: '1.0',
        consumer_secret: 'MCD8BKwGdgPHvAuvgvz4EQpqDAtx89grbuNMRd7Eh98',
        token_secret: 'J6zix3FfA9LofH0awS24M3HcBYXO5nI1iYe8EfBA'
      },
      form: {
        status: 'setting up my twitter 私のさえずりを設定する'
      }
    },
    oauth: {
      consumer_secret: 'MCD8BKwGdgPHvAuvgvz4EQpqDAtx89grbuNMRd7Eh98',
      token_secret: 'J6zix3FfA9LofH0awS24M3HcBYXO5nI1iYe8EfBA',
      signature: 'yOahq5m0YjDDjfjxHaXEsW9D+X0=',
      params: {
        oauth_consumer_key: 'GDdmIQH6jhtmLUypg82g',
        oauth_nonce: 'oElnnMTQIZvqvlfXM56aBLAf5noGD0AQR3Fmi7Q6Y',
        oauth_signature_method: 'HMAC-SHA1',
        oauth_token: '819797-Jxq8aYUDRmykzVKrgoLhXSq67TEa5ruc4GJC2rWimw',
        oauth_timestamp: '1272325550',
        oauth_version: '1.0'
      }
    }
  },
  upsignRSA: {
    request: {
      method: 'POST',
      url: 'http://api.twitter.com/1/statuses/update.json',
      oauth: {
        consumer_key: 'GDdmIQH6jhtmLUypg82g',
        nonce: 'oElnnMTQIZvqvlfXM56aBLAf5noGD0AQR3Fmi7Q6Y',
        signature_method: 'RSA-SHA1',
        token: '819797-Jxq8aYUDRmykzVKrgoLhXSq67TEa5ruc4GJC2rWimw',
        timestamp: '1272325550',
        version: '1.0',
        private_key: rsaPrivatePEM
      },
      form: {
        status: 'setting up my twitter 私のさえずりを設定する'
      }
    },
    oauth: {
      signature: 'fF4G9BNzDxPu/htctzh9CWzGhtXo9DYYl+ZyRO1/QNOhOZPqnWVUOT+CGUKxmAeJSzLKMAH8y/MFSHI0lzihqwgfZr7nUhTx6kH7lUChcVasr+TZ4qPqvGGEhfJ8Av8D5dF5fytfCSzct62uONU0iHYVqainP+zefk1K7Ptb6hI=',
      params: {
        oauth_consumer_key: 'GDdmIQH6jhtmLUypg82g',
        oauth_nonce: 'oElnnMTQIZvqvlfXM56aBLAf5noGD0AQR3Fmi7Q6Y',
        oauth_signature_method: 'RSA-SHA1',
        oauth_token: '819797-Jxq8aYUDRmykzVKrgoLhXSq67TEa5ruc4GJC2rWimw',
        oauth_timestamp: '1272325550',
        oauth_version: '1.0'
      }
    }
  },
  rfc5849: {
    request: {
      method: 'POST',
      url: 'http://example.com/request?b5=%3D%253D&a3=a&c%40=&a2=r%20b',
      oauth: {
        consumer_key: '9djdj82h48djs9d2',
        nonce: '7d8f3e4a',
        signature_method: 'HMAC-SHA1',
        token: 'kkk9d7dh3k39sjv7',
        timestamp: '137131201',
        consumer_secret: 'j49sk3j29djd',
        token_secret: 'dh893hdasih9',
        realm: 'Example'
      },
      form: {
        c2: '',
        a3: '2 q'
      }
    },
    oauth: {
      signature: 'OB33pYjWAnf+xtOHN4Gmbdil168=',
      params: {
        realm: 'Example',
        oauth_consumer_key: '9djdj82h48djs9d2',
        oauth_nonce: '7d8f3e4a',
        oauth_signature_method: 'HMAC-SHA1',
        oauth_timestamp: '137131201',
        oauth_token: 'kkk9d7dh3k39sjv7',
        oauth_version: '1.0'
      }
    }
  },
  rfc5849RSA: {
    request: {
      method: 'POST',
      url: 'http://example.com/request?b5=%3D%253D&a3=a&c%40=&a2=r%20b',
      oauth: {
        consumer_key: '9djdj82h48djs9d2',
        nonce: '7d8f3e4a',
        signature_method: 'RSA-SHA1',
        token: 'kkk9d7dh3k39sjv7',
        timestamp: '137131201',
        private_key: rsaPrivatePEM,
        realm: 'Example'
      },
      form: {
        c2: '',
        a3: '2 q'
      }
    },
    oauth: {
      signature: 'ThNYfZhYogcAU6rWgI3ZFlPEhoIXHMZcuMzl+jykJZW/ab+AxyefS03dyd64CclIZ0u8JEW64TQ5SHthoQS8aM8qir4t+t88lRF3LDkD2KtS1krgCZTUQxkDL5BO5pxsqAQ2Zfdcrzaxb6VMGD1Hf+Pno+fsHQo/UUKjq4V3RMo=',
      params: {
        realm: 'Example',
        oauth_consumer_key: '9djdj82h48djs9d2',
        oauth_nonce: '7d8f3e4a',
        oauth_signature_method: 'RSA-SHA1',
        oauth_timestamp: '137131201',
        oauth_token: 'kkk9d7dh3k39sjv7',
        oauth_version: '1.0'
      }
    }
  },
  plaintext: {
    request: {
      method: 'POST',
      url: 'https://dummy.com',
      oauth: {
        consumer_secret: 'consumer_secret',
        token_secret: 'token_secret',
        signature_method: 'PLAINTEXT'
      }
    },
    oauth: {
      signature: 'consumer_secret&token_secret'
    }
  }
};

var client = function client(args) {
  return compose(Request.defaults(args), function () {
    return args.url ? Request.url(args.url) : function (_ref) {
      var options = _ref.options;
      return { options };
    };
  }(), function () {
    return args.qs ? Request.qs(args.qs) : function (_ref2) {
      var options = _ref2.options;
      return { options };
    };
  }(), function () {
    return args.form ? Request.form(args.form) : args.json ? Request.json(args.json) : args.body ? Request.body(args.body) : function (_ref3) {
      var options = _ref3.options;
      return { options };
    };
  }(), function () {
    return args.oauth ? mw(args.oauth) : function (_ref4) {
      var options = _ref4.options;
      return { options };
    };
  }(), function () {
    return function (_ref5) {
      var options = _ref5.options,
          body = _ref5.body;
      return body ? Request.length()({ options, body }) : { options };
    };
  }()

  // Request.send(),

  // Response.buffer(),
  // Response.status(),
  // Response.parse(),

  )();
};

var parse = {
  header: function header(payload) {
    return payload.replace('OAuth', '').trim().split(',').map(function (kvp) {
      return kvp.split('=');
    }).reduce(function (all, _ref6) {
      var _ref7 = _slicedToArray(_ref6, 2),
          key = _ref7[0],
          value = _ref7[1];

      return all[key] = decodeURIComponent(value.replace(/"/g, '')), all;
    }, {});
  },

  query: function query(payload) {
    return qs.parse(payload.split('?')[1]);
  },

  body: function body(payload) {
    return qs.parse(payload);
  }
};

describe('sign', function () {

  it('reqsign', _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    var _ref9, options, payload;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            t.equal(oauth.hmacsign(sign.reqsign.request.method, sign.reqsign.request.url, sign.reqsign.oauth.params, sign.reqsign.oauth.consumer_secret), sign.reqsign.oauth.signature, 'oauth_signature should be correct');

            _context.next = 3;
            return client(sign.reqsign.request);

          case 3:
            _ref9 = _context.sent;
            options = _ref9.options;
            payload = parse.header(options.headers.Authorization);


            t.equal(payload.oauth_signature, sign.reqsign.oauth.signature, 'oauth_signature should be correct');

            delete payload.oauth_signature;
            t.deepEqual(payload, sign.reqsign.oauth.params, 'all other oauth parameters should be correct');

          case 9:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, undefined);
  })));

  it('reqsignRSA', _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
    var _ref11, options, payload;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            t.equal(oauth.rsasign(sign.reqsignRSA.request.method, sign.reqsignRSA.request.url, sign.reqsignRSA.oauth.params, rsaPrivatePEM), sign.reqsignRSA.oauth.signature, 'oauth_signature should be correct');

            _context2.next = 3;
            return client(sign.reqsignRSA.request);

          case 3:
            _ref11 = _context2.sent;
            options = _ref11.options;
            payload = parse.header(options.headers.Authorization);


            t.equal(payload.oauth_signature, sign.reqsignRSA.oauth.signature, 'oauth_signature should be correct');

            delete payload.oauth_signature;
            t.deepEqual(payload, sign.reqsignRSA.oauth.params, 'all other oauth parameters should be correct');

          case 9:
          case 'end':
            return _context2.stop();
        }
      }
    }, _callee2, undefined);
  })));

  it('accsign', _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
    var _ref13, options, payload;

    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            t.equal(oauth.hmacsign(sign.accsign.request.method, sign.accsign.request.url, sign.accsign.oauth.params, sign.accsign.oauth.consumer_secret, sign.accsign.oauth.token_secret), sign.accsign.oauth.signature, 'oauth_signature should be correct');

            _context3.next = 3;
            return client(sign.accsign.request);

          case 3:
            _ref13 = _context3.sent;
            options = _ref13.options;
            payload = parse.header(options.headers.Authorization);


            t.equal(payload.oauth_signature, sign.accsign.oauth.signature, 'oauth_signature should be correct');

            delete payload.oauth_signature;
            t.deepEqual(payload, sign.accsign.oauth.params, 'all other oauth parameters should be correct');

          case 9:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, undefined);
  })));

  it('accsignRSA', _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
    var _ref15, options, payload;

    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            t.equal(oauth.rsasign(sign.accsignRSA.request.method, sign.accsignRSA.request.url, sign.accsignRSA.oauth.params, rsaPrivatePEM), sign.accsignRSA.oauth.signature, 'oauth_signature should be correct');

            _context4.next = 3;
            return client(sign.accsignRSA.request);

          case 3:
            _ref15 = _context4.sent;
            options = _ref15.options;
            payload = parse.header(options.headers.Authorization);


            t.equal(payload.oauth_signature, sign.accsignRSA.oauth.signature, 'oauth_signature should be correct');

            delete payload.oauth_signature;
            t.deepEqual(payload, sign.accsignRSA.oauth.params, 'all other oauth parameters should be correct');

          case 9:
          case 'end':
            return _context4.stop();
        }
      }
    }, _callee4, undefined);
  })));

  it('upsign', _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
    var _ref17, options, payload;

    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            t.equal(oauth.hmacsign(sign.upsign.request.method, sign.upsign.request.url, Object.assign({}, sign.upsign.oauth.params, sign.upsign.request.form), sign.upsign.oauth.consumer_secret, sign.upsign.oauth.token_secret), sign.upsign.oauth.signature, 'oauth_signature should be correct');

            _context5.next = 3;
            return client(sign.upsign.request);

          case 3:
            _ref17 = _context5.sent;
            options = _ref17.options;
            payload = parse.header(options.headers.Authorization);


            t.equal(payload.oauth_signature, sign.upsign.oauth.signature, 'oauth_signature should be correct');

            delete payload.oauth_signature;
            t.deepEqual(payload, sign.upsign.oauth.params, 'all other oauth parameters should be correct');

          case 9:
          case 'end':
            return _context5.stop();
        }
      }
    }, _callee5, undefined);
  })));

  it('upsignRSA', _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
    var _ref19, options, payload;

    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            t.equal(oauth.rsasign(sign.upsignRSA.request.method, sign.upsignRSA.request.url, Object.assign({}, sign.upsignRSA.oauth.params, sign.upsignRSA.request.form), rsaPrivatePEM), sign.upsignRSA.oauth.signature, 'oauth_signature should be correct');

            _context6.next = 3;
            return client(sign.upsignRSA.request);

          case 3:
            _ref19 = _context6.sent;
            options = _ref19.options;
            payload = parse.header(options.headers.Authorization);


            t.equal(payload.oauth_signature, sign.upsignRSA.oauth.signature, 'oauth_signature should be correct');

            delete payload.oauth_signature;
            t.deepEqual(payload, sign.upsignRSA.oauth.params, 'all other oauth parameters should be correct');

          case 9:
          case 'end':
            return _context6.stop();
        }
      }
    }, _callee6, undefined);
  })));

  it('rfc5849', _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
    var _ref21, options, payload;

    return regeneratorRuntime.wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            _context7.next = 2;
            return client(sign.rfc5849.request);

          case 2:
            _ref21 = _context7.sent;
            options = _ref21.options;
            payload = parse.header(options.headers.Authorization);


            t.equal(payload.oauth_signature, sign.rfc5849.oauth.signature, 'oauth_signature should be correct');

            delete payload.oauth_signature;
            t.deepEqual(payload, sign.rfc5849.oauth.params, 'all other oauth parameters should be correct');

          case 8:
          case 'end':
            return _context7.stop();
        }
      }
    }, _callee7, undefined);
  })));

  it('rfc5849RSA', _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
    var _ref23, options, payload;

    return regeneratorRuntime.wrap(function _callee8$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return client(sign.rfc5849RSA.request);

          case 2:
            _ref23 = _context8.sent;
            options = _ref23.options;
            payload = parse.header(options.headers.Authorization);


            t.equal(payload.oauth_signature, sign.rfc5849RSA.oauth.signature, 'oauth_signature should be correct');

            delete payload.oauth_signature;
            t.deepEqual(payload, sign.rfc5849RSA.oauth.params, 'all other oauth parameters should be correct');

          case 8:
          case 'end':
            return _context8.stop();
        }
      }
    }, _callee8, undefined);
  })));

  it('plaintext', _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
    var _ref25, options, payload;

    return regeneratorRuntime.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            _context9.next = 2;
            return client(sign.plaintext.request);

          case 2:
            _ref25 = _context9.sent;
            options = _ref25.options;
            payload = parse.header(options.headers.Authorization);


            t.equal(payload.oauth_signature, sign.plaintext.oauth.signature, 'oauth_signature should be correct');

            t.ok(/^\d+$/.test(payload.oauth_timestamp), '');
            t.ok(/^[0-9a-f]+$/.test(payload.oauth_nonce), '');
            t.equal(payload.oauth_version, '1.0');
            t.equal(payload.oauth_signature_method, 'PLAINTEXT');

          case 10:
          case 'end':
            return _context9.stop();
        }
      }
    }, _callee9, undefined);
  })));

  it('invalid transport_method', _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {
    return regeneratorRuntime.wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            _context10.prev = 0;
            _context10.next = 3;
            return client({
              oauth: {
                transport_method: 'headerquery'
              }
            });

          case 3:
            _context10.next = 8;
            break;

          case 5:
            _context10.prev = 5;
            _context10.t0 = _context10['catch'](0);

            t.equal(_context10.t0.message, 'oauth: transport_method invalid', 'should throw');

          case 8:
          case 'end':
            return _context10.stop();
        }
      }
    }, _callee10, undefined, [[0, 5]]);
  })));

  it('invalid method while using transport_method `body`', _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
    return regeneratorRuntime.wrap(function _callee11$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            _context11.prev = 0;
            _context11.next = 3;
            return client({
              url: 'http://example.com/',
              headers: {
                'content-type': 'application/x-www-form-urlencoded; charset=UTF-8'
              },
              oauth: {
                transport_method: 'body'
              }
            });

          case 3:
            _context11.next = 8;
            break;

          case 5:
            _context11.prev = 5;
            _context11.t0 = _context11['catch'](0);

            t.equal(_context11.t0.message, 'oauth: transport_method: body requires POST and ' + 'content-type: application/x-www-form-urlencoded', 'should throw');

          case 8:
          case 'end':
            return _context11.stop();
        }
      }
    }, _callee11, undefined, [[0, 5]]);
  })));

  it('invalid content-type while using transport_method `body`', _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {
    return regeneratorRuntime.wrap(function _callee12$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            _context12.prev = 0;
            _context12.next = 3;
            return client({
              method: 'POST',
              url: 'http://example.com/',
              headers: {
                'content-type': 'application/json; charset=UTF-8'
              },
              oauth: {
                transport_method: 'body'
              }
            });

          case 3:
            _context12.next = 8;
            break;

          case 5:
            _context12.prev = 5;
            _context12.t0 = _context12['catch'](0);

            t.equal(_context12.t0.message, 'oauth: transport_method: body requires POST and ' + 'content-type: application/x-www-form-urlencoded', 'should throw');

          case 8:
          case 'end':
            return _context12.stop();
        }
      }
    }, _callee12, undefined, [[0, 5]]);
  })));

  it('query transport_method', _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13() {
    var _ref30, options, payload;

    return regeneratorRuntime.wrap(function _callee13$(_context13) {
      while (1) {
        switch (_context13.prev = _context13.next) {
          case 0:

            sign.accsign.request.oauth = Object.assign({}, sign.accsign.request.oauth, { transport_method: 'query' });

            _context13.next = 3;
            return client(sign.accsign.request);

          case 3:
            _ref30 = _context13.sent;
            options = _ref30.options;


            t.equal(options.headers.Authorization, undefined, 'authorization header should not be set');

            t.ok(/^\/oauth\/access_token\?.+/.test(options.path), 'path should contain path + query');

            payload = parse.query(options.path);


            t.equal(payload.oauth_signature, sign.accsign.oauth.signature, 'oauth_signature should be correct');

            delete payload.oauth_signature;
            t.deepEqual(payload, sign.accsign.oauth.params, 'all other oauth parameters should be correct');

          case 11:
          case 'end':
            return _context13.stop();
        }
      }
    }, _callee13, undefined);
  })));

  it('query transport_method + form option + url params', _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14() {
    var _ref32, options, payload;

    return regeneratorRuntime.wrap(function _callee14$(_context14) {
      while (1) {
        switch (_context14.prev = _context14.next) {
          case 0:

            sign.rfc5849.request.oauth = Object.assign({}, sign.rfc5849.request.oauth, { transport_method: 'query' });

            _context14.next = 3;
            return client(sign.rfc5849.request);

          case 3:
            _ref32 = _context14.sent;
            options = _ref32.options;


            t.equal(options.headers.Authorization, undefined, 'authorization header should not be set');

            t.ok(/^\/request\?.+/.test(options.path), 'path should contain path + query');

            payload = parse.query(options.path);


            t.equal(payload.oauth_signature, sign.rfc5849.oauth.signature, 'oauth_signature should be correct');

            delete payload.oauth_signature;
            t.deepEqual(payload, Object.assign({}, {
              b5: '=%3D',
              a3: 'a',
              'c@': '',
              a2: 'r b'
            }, sign.rfc5849.oauth.params), 'all other oauth parameters should be correct');

          case 11:
          case 'end':
            return _context14.stop();
        }
      }
    }, _callee14, undefined);
  })));

  it('query transport_method + qs option + url params', _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15() {
    var opts, _ref34, options, payload;

    return regeneratorRuntime.wrap(function _callee15$(_context15) {
      while (1) {
        switch (_context15.prev = _context15.next) {
          case 0:
            opts = Object.assign({}, sign.rfc5849.request);

            opts.url = 'http://example.com/request?a2=r%20b';
            opts.oauth.transport_method = 'query';
            opts.qs = {
              b5: '=%3D',
              a3: ['a', '2 q'],
              'c@': '',
              c2: ''
            };
            delete opts.form;

            _context15.next = 7;
            return client(opts);

          case 7:
            _ref34 = _context15.sent;
            options = _ref34.options;


            t.equal(options.headers.Authorization, undefined, 'authorization header should not be set');

            t.ok(/^\/request\?.+/.test(options.path), 'path should contain path + query');

            payload = parse.query(options.path);


            t.equal(payload.oauth_signature, sign.rfc5849.oauth.signature, 'oauth_signature should be correct');

            delete payload.oauth_signature;
            t.deepEqual(payload, Object.assign({}, {
              a2: 'r b',
              b5: '=%3D',
              a3: ['a', '2 q'],
              'c@': '',
              c2: ''
            }, sign.rfc5849.oauth.params), 'all other oauth parameters should be correct');

          case 15:
          case 'end':
            return _context15.stop();
        }
      }
    }, _callee15, undefined);
  })));

  it('body transport_method', _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16() {
    var opts, _ref36, options, body, payload;

    return regeneratorRuntime.wrap(function _callee16$(_context16) {
      while (1) {
        switch (_context16.prev = _context16.next) {
          case 0:
            opts = sign.accsign.request.oauth = Object.assign({}, sign.accsign.request);

            opts.oauth.transport_method = 'body';
            opts.form = {};

            _context16.next = 5;
            return client(opts);

          case 5:
            _ref36 = _context16.sent;
            options = _ref36.options;
            body = _ref36.body;


            t.equal(options.headers.Authorization, undefined, 'authorization header should not be set');

            t.ok(/^\/oauth\/access_token$/.test(options.path), 'path should not contain querystring');

            payload = parse.body(body);


            t.equal(payload.oauth_signature, sign.accsign.oauth.signature, 'oauth_signature should be correct');

            delete payload.oauth_signature;
            t.deepEqual(payload, sign.accsign.oauth.params, 'all other oauth parameters should be correct');

          case 14:
          case 'end':
            return _context16.stop();
        }
      }
    }, _callee16, undefined);
  })));

  it('body transport_method + form option + url params', _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17() {
    var _ref38, options, body, payload;

    return regeneratorRuntime.wrap(function _callee17$(_context17) {
      while (1) {
        switch (_context17.prev = _context17.next) {
          case 0:

            sign.rfc5849.request.oauth = Object.assign({}, sign.rfc5849.request.oauth, { transport_method: 'body' });

            _context17.next = 3;
            return client(sign.rfc5849.request);

          case 3:
            _ref38 = _context17.sent;
            options = _ref38.options;
            body = _ref38.body;


            t.equal(options.headers.Authorization, undefined, 'authorization header should not be set');

            t.ok(/^\/request\?.+$/.test(options.path), 'path should contain path + querystring');

            payload = parse.body(body);


            t.equal(payload.oauth_signature, sign.rfc5849.oauth.signature, 'oauth_signature should be correct');

            delete payload.oauth_signature;
            t.deepEqual(payload, Object.assign({}, {
              c2: '',
              a3: '2 q'
            }, sign.rfc5849.oauth.params), 'all other oauth parameters should be correct');

          case 12:
          case 'end':
            return _context17.stop();
        }
      }
    }, _callee17, undefined);
  })));

  it('body_hash manually set', _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18() {
    var _ref40, options, payload;

    return regeneratorRuntime.wrap(function _callee18$(_context18) {
      while (1) {
        switch (_context18.prev = _context18.next) {
          case 0:
            _context18.next = 2;
            return client({
              method: 'POST',
              url: 'http://example.com',
              oauth: {
                consumer_secret: 'consumer_secret',
                body_hash: 'ManuallySetHash'
              },
              json: { foo: 'bar' }
            });

          case 2:
            _ref40 = _context18.sent;
            options = _ref40.options;
            payload = parse.header(options.headers.Authorization);

            t.equal(payload.oauth_body_hash, 'ManuallySetHash', 'oauth body hash should be set');

          case 6:
          case 'end':
            return _context18.stop();
        }
      }
    }, _callee18, undefined);
  })));

  it('body_hash automatically built for string', _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19() {
    var _ref42, options, payload;

    return regeneratorRuntime.wrap(function _callee19$(_context19) {
      while (1) {
        switch (_context19.prev = _context19.next) {
          case 0:
            _context19.next = 2;
            return client({
              method: 'PUT',
              url: 'http://www.example.com/resource',
              oauth: {
                body_hash: true
              },
              body: 'Hello World!'
            });

          case 2:
            _ref42 = _context19.sent;
            options = _ref42.options;
            payload = parse.header(options.headers.Authorization);


            t.equal(payload.oauth_body_hash, 'Lve95gjOVATpfV8EL5X4nxwjKHE=', 'https://tools.ietf.org/id/draft-eaton-oauth-bodyhash-00.html#anchor15');

          case 6:
          case 'end':
            return _context19.stop();
        }
      }
    }, _callee19, undefined);
  })));

  it('body_hash automatically built for JSON', _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20() {
    var _ref44, options, payload;

    return regeneratorRuntime.wrap(function _callee20$(_context20) {
      while (1) {
        switch (_context20.prev = _context20.next) {
          case 0:
            _context20.next = 2;
            return client({
              method: 'POST',
              url: 'http://example.com',
              oauth: {
                consumer_secret: 'consumer_secret',
                body_hash: true
              },
              json: { foo: 'bar' }
            });

          case 2:
            _ref44 = _context20.sent;
            options = _ref44.options;
            payload = parse.header(options.headers.Authorization);

            t.equal(payload.oauth_body_hash, 'pedE0BZFQNM7HX6mFsKPL6l+dUo=', 'oauth body hash should be generated');

          case 6:
          case 'end':
            return _context20.stop();
        }
      }
    }, _callee20, undefined);
  })));

  it('body_hash PLAINTEXT signature_method', _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee21() {
    return regeneratorRuntime.wrap(function _callee21$(_context21) {
      while (1) {
        switch (_context21.prev = _context21.next) {
          case 0:
            _context21.prev = 0;
            _context21.next = 3;
            return client({
              method: 'POST',
              url: 'http://example.com',
              oauth: {
                consumer_secret: 'consumer_secret',
                body_hash: true,
                signature_method: 'PLAINTEXT'
              },
              json: { foo: 'bar' }
            });

          case 3:
            _context21.next = 8;
            break;

          case 5:
            _context21.prev = 5;
            _context21.t0 = _context21['catch'](0);

            t.equal(_context21.t0.message, 'oauth: PLAINTEXT signature_method not supported with body_hash signing', 'should throw');

          case 8:
          case 'end':
            return _context21.stop();
        }
      }
    }, _callee21, undefined, [[0, 5]]);
  })));

  it.skip('refresh oauth_nonce on redirect', function () {});

  it.skip('no credentials on external redirect', function () {});
});